<html>
  <head>
        <link rel="stylesheet" href="https://unpkg.com/ress/dist/ress.min.css">
        <%= stylesheet_link_tag "java", :media => "all" %>
    </head>
  <body>
    <p class="html-link"><%= link_to "HTML CSS学習", root_path %></p>
    <p class="title">Javaの学習記録</p>
    <p class="title2">Javaとは</p>
    <p class="text">Javaの特徴①コンパイル言語である。Rubyはスクリプト言語というもの。
    <br>②プラットフォーム非依存。どんな環境でも動くプログラム
    <br>③オブジェクト指向。保守性が高く、拡張性もある。</p>

    <p class="title2">Javaのプログラム実行準備</p>
    <p class="text">①環境変数の設定　コントロールパネル→システムの詳細設定→環境変数から変更
    <br>新しいシステム変数の作成で「JAVA_HOME」変数値「C:\Program Files\Java\jdk1.8.0_311」を追加
    <br>「path」をダブルクリックし、「新規」作成　「%JAVA_HOME%¥bin」を追加
    <br>コマンドプロンプトで[java Ready01]を実行。入力されたものが出てくる！

    <p class="title2">Eclipse</p>
    <p class="text">Eclipseとはオープンソースの統合開発環境のこと。プログラマーの負担を減らしてくれる！
    <br>実際に使ってみるとコンパイルする必要がなくなる！
    </p>

    <p class="title2">Eclipseでプログラムの実行</p>
    <p class="text">プロジェクトの作成（Javaのアプリケーションを作成するときの単位）
    <br>ソースファイルの作成
    <br>public class Ready02 {
    <br>public static void main(String[] args) {
    <br>    System.out.println("Hello World!");
<br>    }
<br>}
<br>
これでHello World!が表示される。
<br>""の間に入れる単語が表示されるところ</p>

<p class="title2">Javaの基本文法</p>
<p class="text">波カッコ（{}）で囲まれたプログラムの塊が<strong>ブロック</strong>と
<br>セミコロン（;）で終わる<strong>文</strong>で構成されている。
<br><br>ブロック・・・①メソッドブロック＝処理を記述するメソッド　②クラスブロック＝メソッドをまとめるクラス
<br></p>
<br>
<p class="text">
  コーティング規約・・・ソースコードの書き方を定めたルールのこと
  <br>
      <br>public class Ready02 {　・・・クラスブロックの始まり
    <br>public static void main(String[] args) {　・・・メソッドブロックの始まり
    <br>    System.out.println("Hello World!");　・・・文字列を出力する処理
<br>    }　・・・メソッドブロックの終わり
<br>}　・・・クラスブロックの終わり

<br><br><br><br>
<p class="text">
  mainメソッド・・・プログラムを実行するときに最初に呼び出されるメソッド。２通りある
  <br>
  ①public static void main(String[] args) {
<br>　　 // 処理（文）
<br>}
<br><br>
②public static void main(String... args) {
<br>    // 処理（文）
<br>}
<br>
<p class="text">
<br>  　System.out.println("Hello WEBCAMP!");
<br>　　System.out.println("Hello Java!");
<br>を連続で入れれば、出力される。
</p>
</p>
</p>

<p class="title2">変数について</p>
<p class="text">変数・・・データ（値）を格納するために準備する名前付きの箱。
変数の役割・・・格納したデータを取り出して使用すること。使用することで複雑なデータや複数のデータを簡単に取り出すこともできる。</p>
<p class="text">変数の宣言・・・型　変数名;
<br>初期化・・・宣言した変数に初期値を代入すること。型　変数名 = 代入するデータ;
<br>
public class Variable01 {
<br>
<br>    public static void main(String[] args) {
<br>        int num1;  // int型の変数num1を宣言
<br>        String str1;  // String型の変数str1を宣言
<br>        num1 = 10;  // num1を初期化
<br>        str1 = "Hello World!";  //str1を初期化
<br>        System.out.println(num1);
<br>        System.out.println(str1);
<br>
<br>        num1 = 20;  // num1に20を再代入
<br>        System.out.println(num1);
<br>
<br>        int num2 = 30;  // int型の変数num2を宣言と同時に初期化
<br>        System.out.println(num2);
<br>    }
}</p>
<p class="text">定数・・・最初に代入した値を後から変更ができない変数のこと。
<br>定数の基本構文・・・final 定数の型 定数名 = 初期値;</p>

<p class="title2">型の基本</p>
<p class="text">①プリミティブ型・・・数値や文字のデータそのものを保持している型
<br>8種類あり、long,int,short,byte,double,float,boolean,char</p>
<p class="text">整数型・・・通常はintを使う、大きい値を使う場合はlongを使う
<br> 浮動小数型・・・通常はdoubleを使う、値によってはfloatを使う
<br>倫理型・・・booleanのみ。格納できる値はfalseかtrueのみ。
<br>文字型・・・charのみ。</p>
<br><br><br>
<p class="text">②参照型・・・データそのものを扱うのではなく、データがある参照先を保持する型
<br>null　＝　参照型変数の中身が何もないことを表現する特別な値</p>
<p class="text">文字列クラス（String型）・・・文字列を扱うことのできるクラス
<br>ラッパークラス・・・プリミティブ型を参照型として扱えるようにできるクラスのこと　（例）Long, Integer, Short, Byte, Double, Float Boolean, Character</p>
<p class="text">ボクシング・・・プリミティブ型をラッパークラス型へ変換すること。逆にラッパークラス型の値からプリミティブ型への変換をアンボクシングという</p>
<p class="text">配列・・・同じ型の複数のデータを１つの変数で扱えるようにしたもの</p>
<p class="text">・プリミティブ型の「long」「double」「boolean」の変数に値を代入して出力
　<br>・ラッパークラスの「Float」「Integer」「Character」の変数に値を代入して出力
　<br>・要素数が5の「int」配列に値を代入して、インデックス番号が3の値を出力</p>
　<p class="text">解答
　<br>public class Chapter05 {
	<br>public static void main(String[] args) {
	<br>	long long1 = 1;
	<br>			System.out.println(long1);
	<br>	double double1 = 2;
	<br>			System.out.println(double1);
	<br>	boolean boolean1 = true;
	<br>			System.out.println(boolean1);
<br><br>
	<br>			Integer i = 100;
	<br>			System.out.println(i);
	<br>			Float f = 1.4142f;
	<br>			System.out.println(f);
	<br>			Character c = 'う';
	<br>			System.out.println(c);
<br><br>
	<br>			int[] array = {0, 10, 20, 30, 40 };
	<br>			System.out.println(array[3]);

<br>	}
<br>}</p>

<p><strong>System.out.println(変数名);</strong>で出力できる！</p>


<p class="title2">演算子について</p>
<p class="text">計算するときに使われる「+」「＝」などの記号を<strong>演算子</strong>と呼ぶ。
<br>b=a+3のような文を<strong>式</strong>と呼ぶ。演算の対象となる「a」や「３」のような部分を<strong>オペランド</strong>と呼ぶ。</p>
<p class="text">計算するときに使用する算術演算子。「+」「-」「*」「/」「％」のようなもの。</p>
<p class="text">↓使用例↓<br>
<br>  int a = 15;
<br>int c;
<br>c = a + 3;  // c = 18
<br>c = a - 5;  // c = 10
<br>c = a * 2;  // c = 20
<br>c = a / 6;  // c = 2
<br>c = a % 4;  // c = 3
</p>

<p class="text">数値型の変数の値に１増加する演算子を<strong>インクリメント演算子</strong>、１減少する演算子を<strong>デクリメント演算子</strong>と呼ぶ。</p>
<p class="text">↓使用例↓<br>
<br>int a;
<br>a = 10;
<br>a++;  // a = 11
<br>a = 10;
<br>a--;  // a = 9
</p>

<p class="text">前置と後置・・・インクリメント・デクリメントには、演算子を前につける前置と後ろにつける後置がある。
<br>どちらの場合でもインクリメント演算子は１増加させ、デクリメント演算子は１減少させることに違いはない。
<br>ただし、以下のように前置と後置で処理が変わってくる場合がある。
<br><br>int a;
<br>int c;

<br>a = 5;
<br>c = ++a;  // a をインクリメントした後に、a が c に代入される
<br>// それぞれの値は、a が「6」で c も「6」

<br><br>a = 5;
<br>c = a++;  // a を c に代入した後に、a がインクリメントされる
<br>// それぞれの値は、a が「6」で c が「5」</p>
<br>
<p class="text"><strong>代入演算子</strong>とは、変数に値を代入したい場合や計算した結果を代入したい場合に使用</p>
<p class="text"> int a;
a = 10;  // a = 10：aに10を代入<br>
a += 5;  // a = 15：aにa+5の結果を代入<br>
a -= 3;  // a = 12：aにa-3の結果を代入<br>
a *= 4;  // a = 48：aにa*4の結果を代入<br>
a /= 2;  // a = 24：aにa/2の結果を代入<br>
a %= 7;  // a = 3 ：aにa%7の結果を代入<br>
</p>

<p class="text"><strong>関係（比較）演算子</strong>とは2つの値が大きいか、小さいか、等しいかを調べる場合に使用する。結果は「boolean」型になる。</p>
<p class="text">int a = 5;
boolean c;<br>

c = a < 5;   // c = false<br>
c = a <= 5;  // c = true<br>
c = a > 4;   // c = true<br>
c = a >= 6;  // c = false<br>
c = a == 5;  // c = true<br>
c = a != 5;  // c = false<br></p>

<p class="text"><strong>論理演算子</strong>とは複数の式を条件とする場合に使用。</p>
<p class="text">
boolean a = true;<br>
boolean b = false;<br>
boolean c;<br>
<br>
c = a && true;   // c = true<br>
c = a && false;  // c = false<br>
c = b || true;   // c = true<br>
c = b || false;  // c = false<br>
c = !a;          // c = false<br>
c = !b;          // c = true  <br>
</p>

<p class="text"><strong>文字列の連結</strong>・・・文字列を連結する場合の演算子は算術演算子の足し算と同じ「+」になる。</p>
<p class="text">String a = "100";<br>
String b = "200";<br>
String c;<br>
c = a + b;        // c = 100200<br>
c = "あ" + "い";   // c = あい</p>

<p class="text"><strong>文字列の等価比較</strong>・・・== 演算子は文字列の比較に用いることもできる。</p>

<p class="text">問題↓<br>
　・「int」の変数「val」を「2 足す 5」を演算した結果で初期化して、値を出力<br>
　・インクリメントした変数「val」の値を出力<br>
　・「5」を掛けた変数「val」の値を出力<br>
　・「boolean」の変数「bool」に「valは50と等しい」を演算した結果を代入して、値を出力<br>
　・変数「bool」に「valは50より小さい AND valを10で割った余りが0」を演算した結果を代入して、値を出力</p>

　<p class="text">解答↓<br>
　public class Chapter06 {<br>
　public static void main(String[] args) {<br>
		int val = 2 + 5;<br>
		System.out.println(val);<br>
		val++;<br>
		System.out.println(val);<br>
<br>
		val *= 5;<br>
		System.out.println(val);<br>
<br>
		boolean bool = (val == 50);<br>
		System.out.println(bool);<br>
<br>
		bool = (val < 50) && (val % 10 == 0);<br>
		System.out.println(bool);<br>
	}<br>
}<br>
</p>
<p class="answer">出力結果↓<br>
7<br>
8<br>
40<br>
false<br>
true<br>
</p>

<p class="title2"><strong>条件分岐</strong>について</p>
<p class="text"><strong>if文</strong>・・・指定した条件により処理を分岐する制御文<br>
if (条件式) {   <br>
    ブロック(処理文);<br>
}  </p>
<p class="text"><strong>else if</strong>・・・複数の条件を指定して処理を分岐させるための制御文<br>
else・・・全てのif文、else-if文の条件を満たさない場合に処理を実行するための制御文<br>
if (条件式) {<br>
    ブロック(処理文);<br>
} else if (条件式) {<br>
    ブロック(処理文);<br>
} else if (条件式) {<br>
    ブロック(処理文);<br>
} else {<br>
    ブロック(処理文)<br>
}<br>
</p>
<p class="text"><strong>switch文</strong>・・・変数の値を条件にして処理を分岐する制御文<br>
<strong>case文</strong>・・・変数とcaseの値が一致する場合、ブロック内の処理を実行<br>
<strong>break文</strong>・・・break文が処理されると、それ以降のcase文は評価されずに、switch文の分岐処理を終了する<br>
<strong>default文</strong>・・・全てcase文の値と一致しない場合、default内のブロックの処理が実行される。default文は必須ではない。「caseに一致しなければ何もしない」という処理を実現したい場合は書かなくてよい。<br><br>
switch (式（変数や値）){<br>
case 値:<br>
    ブロック(処理);<br>
    break;<br>
case 値:<br>
    ブロック(処理);<br>
    break;<br>
default:<br>
    ブロック(処理);<br>
}<br>
</p>
<br><br>
<p class="text">【問題】距離を表すint型の変数を定義し、任意の値で初期化する<br>
距離が5km以下の場合は "とても近いです" を出力する<br>
距離が5kmより長く10km以下の場合は "近いです" を出力する<br>
距離が10kmより長く15km以下の場合は "遠いです" を出力する<br>
距離が15kmより長い場合は "とても遠いです" を出力する<br></p>
<p class="text">【解答】↓<br>
public class Chapter07 {<br>
　public static void main(String[] args) {<br>
　　int distanse = 20;<br>
　　if (distanse <= 5) {<br>
　　　System.out.println("とても近いです");<br>
　　} else if (distanse <= 10) {<br>
　　　System.out.println("近いです");<br>
　　} else if (distanse <= 15) {<br>
　　　System.out.println("遠いです");<br>
　　} else {<br>
　　　System.out.println("とても遠いです");<br>
　　}<br>
　}<br>
}<br>

</p>
<br><br>
<p class="text">【問題】信号の色を表すString型の変数を定義し、 redyellowblueのいずれかで初期化する<br>
色がredの場合は "赤信号です" を出力する<br>
色がyellowの場合は "黄信号です" を出力する<br>
色がblueの場合は "青信号です" を出力する<br>
上記以外の色の場合は "信号の色ではありません" を出力する<br></p>
<p class="text">【解答】↓<br>
public class Chapter07 {<br>
　public static void main(String[] args) {<br>
　　String color = "yellow";<br>
　　switch (color) {<br>
　　case "red":<br>
　　　System.out.println("赤信号です");<br>
　　　break;<br>
　　case "yellow":<br>
　　　System.out.println("黄信号です");<br>
　　　break;<br>
　　case "blue":<br>
　　　System.out.println("青信号です");<br>
　　default:<br>
　　　System.out.println("信号の色ではありません");<br>
　　}<br>
　}<br>
}<br>
</p>

<p class="title2">繰り返し文について</p>
<p class="text"><strong>While文</strong>・・・指定の条件が「true」の間、繰り返し処理を行なう制御文</p>
<p class="text">↓サンプルプログラム↓<br>
public class While01 {<br>
    public static void main(String[] args) {<br>
        int number = 1;<br>
        // while文：ループ開始<br>
        // numberが50未満の場合、ブロックの処理を行なう<br>
        while (number < 50) {<br>
            // ブロック：<br>
            // numberにnumber * 2 を代入して、numberを出力<br>
            number *= 2;<br>
            System.out.println("While01 = " + number);<br>
        }<br>
    }<br>
}</p>
<p class="text"><strong>do-While文</strong>・・・while文と同じように指定の条件が「true」の間、繰り返し処理を行なう制御文。while文との記述上の違いは条件式の位置</p>
<p class="text"><strong>While文とdo-While文の違い</strong>・・・while文とdo-while文の違いは、条件式をブロックの実行前に評価するか、後に評価するかの違い。ループ開始時点で、条件が「false」の場合、while文ではブロックが実行されませんが、do-while文ではブロックが実行される。<br>
サンプルプログラムの「While01.java」と「DoWhile01.java」で、変数の初期化を「int number = 100;」に変更して実行すると違いがわかる。「While01.java」ではブロックが実行されないため何も表示されませんが、「DoWhile01.java」ではブロックが１回実行されて「number = 200」が表示される。</p>

  </body>
</html>